
## Solid devtools chrome extension

**work in progress, not quite usable yet**

- requires changes to solid-js and dom-expressions code [insert link here to the Changes in Solid JS code below]
- so it works only with examples built from this multirepo, which are using modified solid-js from this repo
- it's buggy, does not handle Portal yet
- only shows component tree and component props, no signals yet

It does not (yet) include the existing [solid-debugger](-> add link), and it does not rely on the development mode provided by solid, because

- the ability to use devtools on a production site might turn out to be useful
- devtools should be usable on any code that uses Solid JS, users should not need to add anything to their code for that

## Installation

```bash
git clone https://github.com/fictitious/solid-devtools-multirepo.git
cd solid-devtools-multirepo
git submodule update --init
node .yarn/releases/yarn-3.0.2.cjs install --mode=skip-build
./node_modules/.bin/yarn build
```

Install unpacked extension in chrome from `submodules/solid-devtools/dist/unpacked`

Start examples
```bash
./node_modules/.bin/yarn start-examples
```

video:
- installation
- test2
- solid-tree-view
- solid-site
- test2 in production mode
- debugger hack (on solid-site)

## Overview

### Component Tree

Let's take this slightly modified example from [Solid tutorial](https://www.solidjs.com/tutorial/flow_for?solved)

```typescript
import type {Component} from 'solid-js';
import {createSignal, For} from 'solid-js';

const Cat: Component<{index: number; cat: {id: string; name: string}}> = props => 
    <li>
        <a target="_blank" href={`https://www.youtube.com/watch?v=${props.cat.id}`}>
            {props.index + 1}: {props.cat.name}
        </a>
    </li>
;

const App: Component = () => {
    const [cats, setCats] = createSignal([
        { id: 'J---aiyznGQ', name: 'Keyboard Cat' },
        { id: 'z_AbfPXTKms', name: 'Maru' },
        { id: 'OUtn3pvWmpg', name: 'Henri The Existential Cat' }
    ]);

    return <ul>
        <For each={cats()}>{(cat, i) => <Cat index={i()} cat={cat} />}</For>
    </ul>
    ;
};

export {App};
```

The imaginary component tree for `App` looks like this:
- ovals are components
- diamonds are DOM elements



This tree is imaginary because components are not part of the tree - in fact, there's nothing left
of the components after they are rendered, except their result - DOM nodes.

For devtools, one way to show the component tree is to look where the DOM nodes from each component are inserted into the DOM tree, and recover parent/child component relationship from that.

### Changes to Solid JS code

To do that, Solid JS code is modified to intercept component creation (so we know which DOM nodes were created by each component), and to intercept DOM node insertion (to see where in the tree they are inserted). This is done by the so-called devtools hook script, which is injected into the page and uses wrappers called by modified Solid JS code in [createComponent](add link here)  and [insertParent](add link here). There's also another wrapper in [render](add link here) which tracks DOM elements that are the roots of DOM generated by Solid. 

When the devtools page is not open, the wrappers are no-op functions which just return immediately. Although they are always called by the Solid JS code, this does not seem to noticeably affect performance - the bencmark result for modified Solid JS is .....

### The hook script

The hook script collects information from `createComponent`, `insertParent` and `render` wrappers and stored it in the [registry](add link here). It assigns IDs to component instances and DOM nodes which are results of components, and keeps the map of components and the map of component results:


### The channel and the devtools panel

To show component tree, that information must be transferred from the hook to the devtools panel which runs in a separate javascript context inside chrome devtools. [Channel] is used for that. Channel code was taken from React devtools (it's called the bridge there) and modified to adapt to chrome extension [manifest V3](insert link to known issues).

Messages from page to devtools are [defined here](insert link here). Messages from devtools to page are [defined here](insert link here) 

On the devtools side, there's [RegistryMirror](insert link here) which also has the map of components and map of their results. RegistryMirror is used by the code that infers parent/child relationship for the components [link here](insert link here).

The components panel is ...
The data for showing the component tree is..
The UI for component tree is ...
The UI for component details (props) is ...


